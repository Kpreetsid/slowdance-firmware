#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Â©2017 Wonder Machines

Calculates samples from a pulse density modulation approximation of a specified
waveform and then generates a C header file containing these samples (waveform.h).

The samples are stored in AVR program memory and played back on the electromagnet
in the base of a Slow Dance frame. Using pulse density modulation helps to reduce
the impact of mechanical vibration and the resulting acoustic noise.

Usage: python generate_waveform.py <waveform name>

Valid waveform names are:

* sine
* sine3
* sine9
* squarewave
* sawtooth
* triangle
"""

import math
import sys
import numpy as np

PDM_TARGET_FREQUENCY = 40000.0 # Hz
WAVEFORM_FREQUENCY = 79.75 # Hz

def pdm(samples):
    """ Generate pulse density modulated waveform from samples of a source wave """

    quantization_error = 0
    output = []

    for sample in samples:
        if sample >= quantization_error:
            output += [1]
        else:
            output += [-1]

        quantization_error += output[-1] - sample

    return output

def approximate_squarewave(order):
    """
    Returns a function which approximates a squarewave
    by summing odd harmonics to the given order
    """
    is_odd = lambda x: x % 2 == 1
    harmonic_orders = list(filter(is_odd, range(0, order + 1)))

    return lambda angle: sum([math.sin(n * angle) / n for n in harmonic_orders])

def squarewave(angle):
    """ Sample a squarewave with a period of 2 pi """
    if angle < math.pi:
        return -1
    else:
        return 1

def sawtooth(angle):
    """ Sample a sawtooth wave with a period of 2 pi """
    return (angle / (2 * math.pi) - 0.5) * 2.0

def triangle(angle):
    """ Sample a triangle wave with a period of 2 pi """
    if angle < math.pi / 2:
        return angle / (math.pi / 2)
    elif angle < math.pi:
        sample = (angle - math.pi / 2) / (math.pi / 2)
        return 1 - sample
    elif angle < 3 * math.pi / 2:
        sample = (angle - math.pi) / (math.pi / 2)
        return -sample
    else:
        sample = (angle - 3 * math.pi / 2) / (math.pi / 2)
        return -1 + sample

WAVEFORMS = {
    'sine': approximate_squarewave(1),
    'sine3': approximate_squarewave(3),
    'sine9': approximate_squarewave(9),
    'squarewave': squarewave,
    'sawtooth': sawtooth,
    'triangle': triangle,
}

def generate_header(filename, pulses):
    """
    Creates a C header file containing the given PDM samples
    as an array in AVR program memory
    """

    header = (
        "// Generated by %s\n\n"
        "#ifndef H_WAVEFORM\n"
        "#define H_WAVEFORM\n\n"
        "PROGMEM const unsigned char waveform[] = {\n"
        "%s\n"
        "};\n\n"
        "const unsigned int PDM_TARGET_FREQUENCY = %d;\n"
        "const unsigned int WAVEFORM_SIZE = %d;\n\n"
        "#endif\n"
    )

    array_text = "\t"

    i = 0
    for pulse in pulses:
        pulse_byte = 0xff if pulse > 0 else 0
        array_text += str(pulse_byte) + ", "
        i += 1

        if i > 15:
            array_text += "\n\t"
            i = 0

    with open(filename, 'w') as header_file:
        header_file.write(header % (sys.argv[0], array_text, PDM_TARGET_FREQUENCY, len(pulses)))

def main():
    """ Entrypoint """

    # Default to sinewave
    func = WAVEFORMS['sine']

    # Use a different waveform if it was specified by name
    if len(sys.argv) > 1:
        if sys.argv[1] in WAVEFORMS:
            func = WAVEFORMS[sys.argv[1]]
        else:
            print("Unrecognized waveform name")
            print("Options are:", WAVEFORMS.keys())
            exit(1)

    # Calculate the PDM samples from the given waveform function
    angles = np.linspace(0, 2 * math.pi, math.ceil(PDM_TARGET_FREQUENCY / WAVEFORM_FREQUENCY))
    waveform = [func(angle) for angle in angles]
    pulses = pdm(waveform)

    generate_header('waveform.h', pulses)

    # Plot the waveform
    """
    import matplotlib.pyplot as plt

    plt.plot(angles, waveform)
    plt.plot(angles, pulses)
    plt.show()
    """

main()
